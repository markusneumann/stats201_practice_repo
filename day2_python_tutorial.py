# -*- coding: utf-8 -*-
"""day2_python_tutorial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gvwa3R1iLW2N0Rn-iaCmmpyTCuOSlT1T

# Python Tutorial (Day 2)

## Numpy

Numpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays.

### Arrays

A numpy array is a grid of values, all of the same type, and is indexed by a tuple of nonnegative integers. The number of dimensions is the rank of the array; the shape of an array is a tuple of integers giving the size of the array along each dimension.

Numpy arrays are great alternatives to Python Lists. Some of the key advantages of Numpy arrays are that they are fast, easy to work with, and give users the opportunity to perform calculations across entire arrays.

We can initialize numpy arrays from nested Python lists, and access elements using square brackets:
"""

import numpy as np

a = np.array([1, 2, 3]) # Create a rank 1 array
print(a)
print(type(a))
print(a.shape)
print(a[0], a[1], a[2])
a[0] = 5                # Change an element of the array
print(a)

b = np.array([[1,2,3],[4,5,6]])   # Create a rank 2 array
print(b)

print(b.shape)
print(b.size)
print(b[0, 0], b[0, 1], b[1, 0])

"""Numpy also provides many functions to create arrays:"""

a = np.zeros((2,2))  # Create an array of all zeros
print(a)

e = np.random.random((2,2)) # Create an array filled with random values
print(e)

"""### Array indexing

Numpy offers several ways to index into arrays.

Slicing: Similar to Python lists, numpy arrays can be sliced. Since arrays may be multidimensional, you must specify a slice for each dimension of the array:
"""

# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Use slicing to pull out the subarray consisting of the first 2 rows
# and columns 1 and 2; b is the following array of shape (2, 2):
# [[2 3]
#  [6 7]]
b = a[:2, 1:3]
b

"""A slice of an array is a view into the same data, so modifying it will modify the original array."""

print(a[0, 1])
b[0, 0] = 77    # b[0, 0] is the same piece of data as a[0, 1]
print(a[0, 1])

print(a)

# If you want to avoid this, make a copy
b = a[:2, 1:3].copy()
b
print(b)

"""Two ways of accessing the data in the middle row of the array.
Mixing integer indexing with slices yields an array of lower rank,
while using only slices yields an array of the same rank as the
original array:
"""

row_r1 = a[1, :]    # Rank 1 view of the second row of a
row_r2 = a[1:2, :]  # Rank 2 view of the second row of a
print(row_r1, row_r1.shape)
print(row_r2, row_r2.shape)

"""For brevity I left out a lot of details about numpy array indexing; if you want to know more you should read the [documentation](https://docs.scipy.org/doc/numpy/user/quickstart.html#the-basics).

### Reshape

Sometimes we want to change the dimensions of an array while keeping its values. In this case, we use [reshape](https://numpy.org/doc/stable/reference/generated/numpy.reshape.html).
"""

a = np.array([[1,2,3], [4,5,6]])
print(a)
print(a.shape) # 2 rows and 3 columns
print(np.reshape(a, 6)) # 6 elements
print(np.reshape(a, (6,1))) # 6 rows, 1 column
print(np.reshape(a, (3,2))) # 3 rows, 2 columns
print(np.reshape(np.reshape(a, 6), (2,3))) # 6 elements, then back to 2 rows and 3 columns

"""### Datatypes

Every numpy array is a grid of elements of the same type. Numpy provides a large set of numeric datatypes that you can use to construct arrays. Numpy tries to guess a datatype when you create an array, but functions that construct arrays usually also include an optional argument to explicitly specify the datatype. Here is an example:
"""

x = np.array([1, 2])  # Let numpy choose the datatype
y = np.array([1.0, 2.0])  # Let numpy choose the datatype
z = np.array([1, 2], dtype=np.float64)  # Force a particular datatype

print(x.dtype, y.dtype, z.dtype)

"""You can read all about numpy datatypes in the [documentation](http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html). See also: [extended precision](https://numpy.org/doc/stable/user/basics.types.html#extended-precision) on 64-bit floating numbers.

### Array math

Basic mathematical functions operate elementwise on arrays, and are available both as operator overloads (e.g. +) and as functions in the numpy module:
"""

x = np.array([[1,2],[3,4]], dtype=np.float64)
y = np.array([[5,6],[7,8]], dtype=np.float64)
print(x)
print(y)

# Elementwise sum; both produce the array
print(x + y)
print(np.add(x, y))

# Elementwise difference; both produce the array
print(x - y)
print(np.subtract(x, y))

# Elementwise product; both produce the array
print(x * y)
print(np.multiply(x, y))

# Elementwise division; both produce the array
# [[ 0.2         0.33333333]
#  [ 0.42857143  0.5       ]]
print(x / y)
print(np.divide(x, y))

# Elementwise square root; produces the array
# [[ 1.          1.41421356]
#  [ 1.73205081  2.        ]]
print(np.sqrt(x))

"""### Exercise

Given the arrays a and b,


1.   From a, select all but the first and last element
2.   Reshape the result into two rows and three columns
3.   Multiply the resulting matrix with b


"""

a=np.array(range(1,9))
b=np.array([[1,4,2],[7,5,3]])
a = np.reshape(a[1:-1],(2,3))
print(a*b)

"""## Data Frames

In computational social science, a lot of data come in tabular format. In R, we use built-in data frames. In Python, we use [Pandas](https://pandas.pydata.org/pandas-docs/stable/reference/index.html) data frames.

We will learn what Pandas is capable of by exploring the [Complete Competitive PokÃ©mon Database](https://www.kaggle.com/datasets/giorgiocarbone/complete-competitive-pokmon-datasets-may-2022?select=df_pokemon.csv).

![](https://static.wikia.nocookie.net/pokemon/images/9/95/Kanto_Pok%C3%A9mon.png/revision/latest/scale-to-width-down/1000?cb=20190718185033)
"""

# Since Kaggle requires an account, I'm providing the dataset for you
# Download it into your Colab session like this:
!gdown '1SbMti6NKz2ovoRtRXdLS2eFnNvuQoSNh'
# And extract the zip file
!unzip dataset_pokemon.zip

"""### Basics"""

# Load pandas
import pandas as pd

# Read in one of the csv files and take a look at it
df = pd.read_csv("dataset_pokemon/df_pokemon.csv")
df

# To save the dataframe back to a csv file
df.to_csv('dataset_pokemon/df_pokemon_2.csv', index = False)
# You could also save to Google Drive the same way
# df.to_csv('/content/drive/yourdrive/df_pokemon_2.csv', index = False)

# To access a single column
print(df['Name'])

# In pandas, columns are referred to as Series
print(type(df['Name']))

# To get a specific value of a column, by index
print(df['Name'][0])
print(df['Name'][5:9])

# Number of rows and columns
df.shape

# Get an entire row
print(df.iloc[2])

# To turn a column back into a numpy array
print(df['HP'].values)
# Alternatively
print(df['HP'].to_numpy())
# To a list
print(df['HP'].to_list())

# Looping over the values of a series with enumerate
for i,j in enumerate(df['Name']):
  print(i,j)

# Unique list of types
df['Type1'].unique()

# The number of times each type occurs
df['Type1'].value_counts()

"""### Sorting"""

# Sort the data frame to get the Pokemon with the highest HP
df = df.sort_values('HP', ascending = False)
print(df['Name'][0])
# This isn't quite working yet
# It still shows the Pokemon whose index is 0

# Reset index to 0:N
df = df.reset_index()

# Now it works
print(df['Name'][0])

# By default, reset_index will make the old index a column in case we want it back
# To prevent this, use drop = True
# df = df.reset_index(drop = True)

"""### Subsetting"""

# Keep only specific columns
df[['Name', 'Generation', 'Type1']]

# Restrict the data frame to all Pokemon whose Type is Psychic
df[df['Type1'] == 'Psychic']

# Restrict the data frame to all Pokemon whose Type is either Grass, Water, or Steel
df[df['Type1'].isin(['Grass', 'Water', 'Steel'])]

# Create new a column indicating whether a Pokemon's speed is over 50
df['Speed_categorical'] = 'Slow'
df.loc[df['Speed'] > 50, 'Speed_categorical'] = 'Fast'
df['Speed_categorical']

# Remove rows based on whether the value of the row in a specific column is NA
df.dropna(subset = ['Evolves_from'])

"""### Grouping"""

# If we wanted to know which type of pokemon tends to have the highest speed, we might use group_by
df_grouped = df.groupby('Type1')
df_grouped['Speed'].mean().sort_values(ascending = False)

# For more descriptive statistics, we can use describe
df_grouped['Speed'].describe()

"""### Merging"""

# Merge with another data frame
# The file df_types.csv contains information on when each type was introduced
types = pd.read_csv("dataset_pokemon/df_types.csv")
types

# The columns names in types already exist in df, so let's rename them first
types.columns = ['Type_Name', 'Type_Generation']
types

# The type in types is all lowercase, whereas in df, it starts with an uppercase letter
# To merge, create a new column in df that is all lowercase
# To use string operations in pandas, just put .str after the column - then you can use normal string operations
df['Type_Name'] = df['Type1'].str.lower()
df['Type_Name']

# Finally, we can merge
df_merged = df.merge(types, on = 'Type_Name')
# Note that the order of the rows (and their indexes) have changed
df_merged

# Concatenating data frames
# Let's say you have two separate data frames,
# one with all Dragon Pokemon, and one with all Fairy Pokemon
df_dragon = df[df['Type1'] == 'Dragon']
df_fairy = df[df['Type1'] == 'Fairy']

# To stack them on top of each other, use concat
df_combined = pd.concat([df_dragon, df_fairy])
df_combined

"""### Apply"""

# What if we wanted to make the first letter in the all lowercase strings uppercase instead
# This is easy enough for one string:
'grass'[0].upper() + 'grass'[1:]

# But since it isn't a pre-defined function in pandas, it can't be applied to the whole column
# For this, we use apply
# First we define a function that will be applied to each element in the column
def capitalize_string(string):
  string = string[0].upper() + string[1:]
  return(string)

capitalize_string('string')

# Then we apply it
types2 = types['Type_Name'].apply(capitalize_string)

types2

"""### Exercise

You are preparing for a match against an opponent who is known for having a strong Charizard, a Fire/Flying type. You decide that you need to find a Pokemon that can resist its attacks. Compile a list of Pokemon against which Fire attacks are not very effective and sort it in descending order by Special Defense. You will need the file `bridge_type_type_MOVE_EFFECTIVENESS_ON_POKEMON.csv` to do this.

## Miscellaneous

### String operations
"""

"Combining two strings is easy." + " Just put a plus between them."

"Replacing part of a string is a little harder.".replace("harder", "bit more difficult")

"To delete something from a string, just replace with an empty string.".replace("something ", "")

"To split two strings, do the following: Use split, and provide a separator.".split(":")

"contains" in "To detect whether a string contains a substring, use in."

"""### Plotting

#### Matplotlib

Matplotlib is the most commonly used plotting library for data science.
"""

import matplotlib.pyplot as plt

"""By running this [IPython magic command](https://ipython.readthedocs.io/en/stable/interactive/magics.html), we will be displaying plots inline (as opposed to having to save them on the hard drive and then viewing them from there)."""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

"""The most important function in `matplotlib` is plot, which allows you to plot 2D data. Here is a simple example:"""

# Scatterplot
# The "o" makes it so it draws points rather than a line
plt.plot(df['HP'], df['Attack'], "o")
plt.xlabel('HP')
plt.ylabel('Attack')
plt.title('Attack relative to HP')

# Plotting multiple plots on top of one another using different colors
plt.plot(df['HP'], df['Attack'], "o")
plt.plot(df['HP'], df['Defense'], "o")
plt.xlabel('HP')
plt.ylabel('Attack & Defense')
plt.legend(['Attack','Defense'])

# To see how a variable is distributed, histograms are useful
plt.hist(df['HP'], bins = 20)

"""#### Seaborn

A more modern alternative to matplotlib is Seaborn. It looks a little nicer by default, and is easier to use. You can still use the same `%matplotlib inline` command to make plots show up inline.
"""

import seaborn as sns

sns.scatterplot(x = df['HP'], y = df['Attack'])
sns.scatterplot(x = df['HP'], y = df['Defense'])

sns.histplot(df['HP'])

# This is a density plot - a smoothed version of a histogram
# When would this be preferable to a histogram?
sns.kdeplot(df['HP'])

# Saving a plot to a file
hp_kde = sns.kdeplot(df['HP'])
fig = hp_kde.get_figure()
fig.savefig("hp_kde.png")

"""### Saving & loading data

#### Writing
"""

df['image_url'][1]

# With open opens a connection to a file
# the 'w' argument makes it so that it is used as a writer
with open('dataset_pokemon/image_urls.txt', 'w') as writer:
  # Then loop over every element in the df['image_url'] column
  for word in df['image_url']:
    # And write it to the file in the connection
    # The '\n' Makes a new line after each written word, so that we have one line per URL
    writer.write(word + '\n')

"""#### Loading"""

# Read them back in
with open('dataset_pokemon/image_urls.txt', 'r') as f:
    # The splitlines 'reverses' the '\n'
    image_urls = f.read().splitlines()
image_urls

"""#### Appending"""

# Appending to an existing file instead of writing to a new one
text2 = ["this is not a URL", "neither is this"]
with open('dataset_pokemon/image_urls.txt', 'a') as writer:
  for word in text2:
    writer.write(word + '\n')

# Load it again to see what it looks like
with open('dataset_pokemon/image_urls.txt') as f:
    content = f.read().splitlines()
content[-5:] # Last 5 elements

"""### os package
The os package allows you to interact with your computer's filesystem from within Python.
"""

import os
#list all the files in a directory
os.listdir('dataset_pokemon')

# Full path to the first file in the directory
path1 = "/content/dataset_pokemon/" + os.listdir('dataset_pokemon')[0]
path1

# get only the basename of a file, not the full path
os.path.basename(path1)

# check whether a file (or directory) exists
os.path.exists(path1)

# make a new directory
os.mkdir("new_directory")

"""### Exercise

Write a loop that makes one density plot for the HP of all Pokemon of a given type, and saves it to a folder called `density_plots`. Write this loop so that when you re-run it, it checks whether it has already made the plot for the respective Pokemon type, and if so, doesn't make it again.
"""